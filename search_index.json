[["index.html", "Skuterud OS Section 1 About", " Skuterud OS Moritz Shore 2023-12-03 Section 1 About This a site which documents the model setup for Skuterud in SWAT+ using the “OPTAIN-style” COCOA approach (Schürz Christoph et al. 2022). References "],["building-with-buildr.html", "Section 2 Building with BuildR 2.1 DEM", " Section 2 Building with BuildR This OPTAIN-style model setup will be created using SWATbuildR (Schürz Christoph et al. 2022). This allows for a field-scale level of detail within the SWAT+ model, also known as COCOA …(TBC) For our model setup, the we need many maps/layers. These include elevation, soil, aquifer, land, and channel, see figure XXX Figure 2.1: ‘Required vector and rasrer inputs for a SWAT+ model setup with SWATbuildR’, Figure 2.1 of (Schürz Christoph et al. 2022) We will first set up the BuildR: this will not be needed once the package is released. # Script version of SWATbuildR ------------------------------------- # Version 1.5.17 # Date: 2023-08-14 # Developer: Christoph Schürz christoph.schuerz@ufz.de # # This is a script version of the SWATbuildR workflow that is under # development. The functional workflow works already as it will be # implemented in a final R package version. # Land, channel, reservoir, and point source objects are already # implemented. Further object types and functional features will be # implemented over time. # ------------------------------------------------------------------ # Project path (where output files are saved) ---------------------- project_path &lt;- &#39;project_data/skuterud_swat/&#39; project_name &lt;- &#39;skuterud&#39; # load functions: fns &lt;- sapply(list.files(&#39;project_data/SWATbuildR/functions&#39;, full.names = T), source) rm(fns) data_path &lt;- paste(project_path, project_name, &#39;data&#39;, sep = &#39;/&#39;) ## Create data folders dir.create(paste0(data_path, &#39;/vector&#39;), recursive = T, showWarnings = FALSE) dir.create(paste0(data_path, &#39;/raster&#39;), recursive = T, showWarnings = FALSE) ## Create data folders dir.create(paste0(data_path, &#39;/vector&#39;), recursive = T, showWarnings = FALSE) dir.create(paste0(data_path, &#39;/raster&#39;), recursive = T, showWarnings = FALSE) ## Check if the installed R version is greater than the required one check_r_version(&#39;4.2.1&#39;) ## Install and load R packages install_load(crayon_1.5.1, dplyr_1.0.10, forcats_0.5.1, ggplot2_3.3.6, lubridate_1.8.0, purrr_1.0.0, readr_2.1.2, readxl_1.4.0, stringr_1.4.0, tibble_3.1.8, tidyr_1.2.0, vroom_1.5.7) install_load(sf_1.0-8, sfheaders_0.4.0, lwgeom_0.2-8, terra_1.7-3, whitebox_2.1.5, units_0.8-0) install_load(DBI_1.1.3, RSQLite_2.2.15) # wbt_exe &lt;- list.files(path = find.package(&quot;whitebox&quot;), # pattern = &#39;whitebox_tools.exe&#39;, # recursive = TRUE, full.names = TRUE) # wbt_init(exe_path = wbt_exe) Our first step for this setup is to process the digital elevation model (DEM). Required packages for this section: require(dplyr) require(terra) require(mapview) require(sf) require(whitebox) 2.1 DEM The DEM is necessary for a variety of things within our model setup, such as the watershed, stream network, and object connectivities. The DEM we will use is sourced from hoydedata.no and has full coverage of Norway at 1m resolution. It is important that we use a high resolution DEM as our flow routes and connectivity calculations depend on elements such as elevated road networks: Figure 2.2: Schürz et al. (2022) The tile with coverage of our catchment “Skuterud” is dtm1_33_124_113. This raster map is in .tif format. We can read in a (low resolution preview) map of this file using mapview and terra. DEM &lt;- terra::rast(&quot;project_data/input/DEM/dtm1_33_124_113.tif&quot;) We know approximately where our catchment will be: approx &lt;- read_sf(&quot;project_data/input/DEM/reference/skuterud_general_area.shp&quot;) mapview(approx, map.types = &quot;Esri.WorldImagery&quot;) We can crop our large DEM file to this estimation, which will dramatically reduce computation times. DEM_crop &lt;- terra::crop(x = DEM, y = approx) terra::writeRaster(x = DEM_crop, filename = &quot;project_data/input/DEM/skuterud_DEM.tif&quot;) 2.1.1 Watershed To start, we need to delineate our catchment boundaries, which we will do with the digital elevation map. Processing of this map will be done with the help of WhiteBoxTools (ref). whitebox::wbt_version() First we breach depressions. Question, is fill = TRUE ok here? Are there any other parameters that should be adjusted? wbt_breach_depressions_least_cost( dem = &quot;project_data/input/DEM/skuterud_DEM.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions.tif&quot;, dist = 5, # Maximum search distance for breach paths in cells. fill = TRUE # Optional flag indicating whether to fill any remaining unbreached depressions. ) Time to calculate our flow accumulation using the D8 algorithm. wbt_d8_flow_accumulation( input = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation.tif&quot;) And the D8 pointer: wbt_d8_pointer( dem = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer.tif&quot; ) Where is our catchment outlet? It is located here: Figure 2.3: Skuterud Outlet The measuring station itself is actually behind the road, where a tunnel leads directly to the instruments, however to get an accurate basin from the DEM, this allocation is most correct, as water north of the road does not make it into the station. outlet &lt;- &quot;project_data/input/DEM/point/skuterud_outlet.shp&quot; outlet_point &lt;- sf::read_sf(outlet) outlet_map &lt;- mapview::mapview(outlet_point, map.types = &quot;Esri.WorldImagery&quot;) outlet_map Now that we have our outlet point, we need to snap it to our stream network. For that we need a stream network. wbt_extract_streams( flow_accum = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation.tif&quot;, output =&quot;project_data/input/DEM/wbt_intermediates/raster_streams.tif&quot;, threshold = 10000) Lets have a look: stream_rast &lt;- terra::rast(&quot;project_data/input/DEM/wbt_intermediates/raster_streams.tif&quot;) plot(stream_rast) Little hard to see, lets zoom in on the outlet (we got these coords from QGIS) plot(stream_rast, xlim = c(265337.49,265416.12), ylim = c(6623657.26, 6623723.11)) Hmm… This does not look good. The streams flow to the left and cross into the lake somewhere in the east. This does not match reality. Why is this occurring? Its probably because of the elevated road which the stream passes under. This is a common issue and you can read more about it here. But lets get to fixing it by burning in our known stream network from NVE’s map service NEVINA, specifically ELVIS. nve_stream_network &lt;- sf::read_sf(&quot;project_data/input/DEM/line/stream_network/NVEData/Elv/Elv_Elvenett.shp&quot;) %&gt;% select(geometry, elvID) nve_crop &lt;- st_crop(nve_stream_network, st_buffer(approx, 10000)) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries nve_crop$elvID = 1 mapview(nve_crop, map.types = &quot;Esri.WorldImagery&quot;)+outlet_map Looks good. We shall save it sf::write_sf(nve_crop, &quot;project_data/input/DEM/line/stream_network/skuterud_streams.shp&quot;) The NVE stream network is not quite detailed enough to show all the important streams. Therefore it was extended slightly. This step is important because the underground stream passages through the road network will determine the watershed later on. Figure 2.4: Extended stream over road. Burning in the stream network to deal with this r: whitebox::wbt_fill_burn( dem = &quot;project_data/input/DEM/skuterud_DEM.tif&quot;, streams = &quot;project_data/input/DEM/line/stream_network/skuterud_testbed.shp&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/fill_burn.tif&quot;) Now repeating the whole process: wbt_breach_depressions_least_cost( dem = &quot;project_data/input/DEM/wbt_intermediates/fill_burn.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_burn.tif&quot;, dist = 5, # Maximum search distance for breach paths in cells. fill = TRUE # Optional flag indicating whether to fill any remaining unbreached depressions. ) wbt_d8_flow_accumulation( input = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_burn.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation_burn.tif&quot;) wbt_d8_pointer( dem = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_burn.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer_burn.tif&quot; ) wbt_extract_streams( flow_accum = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation_burn.tif&quot;, output =&quot;project_data/input/DEM/wbt_intermediates/raster_streams_burn.tif&quot;, threshold = 10000) stream_rast &lt;- terra::rast(&quot;project_data/input/DEM/wbt_intermediates/raster_streams_burn.tif&quot;) plot(stream_rast, xlim = c(265337.49,265416.12), ylim = c(6623657.26, 6623723.11)) Yes! Looks good. Now: Sticking the point on the stream: wbt_jenson_snap_pour_points( pour_pts = &quot;project_data/input/DEM/point/skuterud_outlet.shp&quot;, streams = &quot;project_data/input/DEM/wbt_intermediates/raster_streams_burn.tif&quot;, output = &quot;project_data/input/DEM/point/outlet_snapped.shp&quot;, snap_dist = 5) #careful with this! Know the units of your data Lets have a look at that snap shall we? snap_outlet &lt;- sf::read_sf(&quot;project_data/input/DEM/point/outlet_snapped.shp&quot;) snap_mapped &lt;- mapview::mapview(snap_outlet, map.types = &quot;Esri.WorldImagery&quot;) snap_buffer &lt;- sf::st_buffer(snap_outlet, 100) stream_rast &lt;- terra::rast(&quot;project_data/input/DEM/wbt_intermediates/raster_streams_burn.tif&quot;) streams_cropped &lt;- terra::crop(stream_rast, snap_buffer) streams_map &lt;- mapview::mapview(streams_cropped, map.types = &quot;Esri.WorldImagery&quot;) streams_map+snap_mapped Looking good, looking great. Moving on: Its the big moment, time to delineate our watershed: wbt_watershed( d8_pntr = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer_burn.tif&quot;, pour_pts = &quot;project_data/input/DEM/point/outlet_snapped.shp&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/skuterud_basin_1m.tif&quot; ) Take it out of the oven, and have a look: WS &lt;- terra::rast(&quot;project_data/input/DEM/wbt_intermediates/skuterud_basin_1m.tif&quot;) # convert to polygon wsshape &lt;- stars::st_as_stars(WS) %&gt;% sf::st_as_sf(merge = T) ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The definition of geographic CRS ## EPSG:4258 got from GeoTIFF keys is not the same as the one from the EPSG ## registry, which may cause issues during reprojection operations. Set ## GTIFF_SRS_SOURCE configuration option to EPSG to use official parameters ## (overriding the ones from GeoTIFF keys), or to GEOKEYS to use custom values ## from GeoTIFF keys and drop the EPSG code. ## Warning in CPL_polygonize(file, mask_name, &quot;GTiff&quot;, &quot;Memory&quot;, &quot;foo&quot;, options, : ## GDAL Message 1: The definition of geographic CRS EPSG:4258 got from GeoTIFF ## keys is not the same as the one from the EPSG registry, which may cause issues ## during reprojection operations. Set GTIFF_SRS_SOURCE configuration option to ## EPSG to use official parameters (overriding the ones from GeoTIFF keys), or to ## GEOKEYS to use custom values from GeoTIFF keys and drop the EPSG code. write_sf(wsshape, &quot;project_data/input/DEM/wbt_intermediates/skuterud_basin_1m.shp&quot;) ## Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI ## Shapefile driver plot(wsshape) That looks good. lets compare it to some literature on Skuterud, from (Bechmann and Deelstra 2006): Figure 2.5: Marianne E. Bechmann &amp; Johannes Deelstra (2006) Quite a big difference in the northwest. The reason for this is an underground channel that feeds water from this field directly into the lake, bypassing the monitoring station. Only during heavy loads will water spill over into the station (personal communication). This is the drainage system, as seen from Google street view: Figure 2.6: Drainage system, Google streetview This means we need to adapt our stream network. This has been done in QGIS like so: Figure 2.7: Added stream for drainage tunnel We need to re-do the whole process again: whitebox::wbt_fill_burn( dem = &quot;project_data/input/DEM/skuterud_DEM.tif&quot;, streams = &quot;project_data/input/DEM/line/stream_network/skuterud_drained.shp&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/fill_drained.tif&quot;) wbt_breach_depressions_least_cost( dem = &quot;project_data/input/DEM/wbt_intermediates/fill_drained.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_drained.tif&quot;, dist = 5, fill = TRUE ) wbt_d8_flow_accumulation( input = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_drained.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation_drained.tif&quot;) wbt_d8_pointer( dem = &quot;project_data/input/DEM/wbt_intermediates/breached_depressions_drained.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer_drained.tif&quot; ) wbt_extract_streams( flow_accum = &quot;project_data/input/DEM/wbt_intermediates/flow_accumulation_drained.tif&quot;, output =&quot;project_data/input/DEM/wbt_intermediates/raster_streams_drained.tif&quot;, threshold = 10000) wbt_jenson_snap_pour_points( pour_pts = &quot;project_data/input/DEM/point/skuterud_outlet.shp&quot;, streams = &quot;project_data/input/DEM/wbt_intermediates/raster_streams_drained.tif&quot;, output = &quot;project_data/input/DEM/point/outlet_snapped.shp&quot;, snap_dist = 5) wbt_watershed( d8_pntr = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer_drained.tif&quot;, pour_pts = &quot;project_data/input/DEM/point/outlet_snapped.shp&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/skuterud_basin_1m.tif&quot; ) WS &lt;- terra::rast(&quot;project_data/input/DEM/wbt_intermediates/skuterud_basin_1m.tif&quot;) wsshape2 &lt;- stars::st_as_stars(WS) %&gt;% sf::st_as_sf(merge = T) ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The definition of geographic CRS ## EPSG:4258 got from GeoTIFF keys is not the same as the one from the EPSG ## registry, which may cause issues during reprojection operations. Set ## GTIFF_SRS_SOURCE configuration option to EPSG to use official parameters ## (overriding the ones from GeoTIFF keys), or to GEOKEYS to use custom values ## from GeoTIFF keys and drop the EPSG code. ## Warning in CPL_polygonize(file, mask_name, &quot;GTiff&quot;, &quot;Memory&quot;, &quot;foo&quot;, options, : ## GDAL Message 1: The definition of geographic CRS EPSG:4258 got from GeoTIFF ## keys is not the same as the one from the EPSG registry, which may cause issues ## during reprojection operations. Set GTIFF_SRS_SOURCE configuration option to ## EPSG to use official parameters (overriding the ones from GeoTIFF keys), or to ## GEOKEYS to use custom values from GeoTIFF keys and drop the EPSG code. write_sf(wsshape2, &quot;project_data/input/DEM/skuterud_basin_1m_drained.shp&quot;) ## Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI ## Shapefile driver mapview(wsshape2, alpha.region = 0.5, map.types = &quot;Esri.WorldImagery&quot;) Looks good. A comparison: mapview(wsshape, map.types = &quot;Esri.WorldImagery&quot;) + mapview(wsshape2, col.region = &quot;orange&quot;, map.types = &quot;Esri.WorldImagery&quot;) 2.1.1.1 BuildR Implementation Now that we have our watershed ready, we can implement it into the BuildR bound_path = &quot;project_data/input/DEM/skuterud_basin_1m_drained.shp&quot; bound &lt;- read_sf(bound_path) %&gt;% select() set_proj_crs(bound, data_path) check_polygon_topology(layer = bound, data_path = data_path, label = &#39;basin&#39;, n_feat = 1, checks = c(F,T,T,T,F,F,F,F)) ## Running topological checks and modifications for the basin layer: ## ## Analyzing basin layer for specific number of features... ## ✔ Number of features correct. ## Analyzing basin layer for MULTIPOLYGON features... ## ✔ No MULTIPOLYGON features identified. ## Analyzing basin layer for invalid features... ## ✔ No invalid features identified. ## ## ## ✔ All checks successful! Saving checked basin layer. An unnumbered section BuildR progress: # Read and prepare input data -------------------------------------- ## Basin boundary # done ## Load and check the soil raster layer soil &lt;- rast(soil_layer_path) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;soil&#39;, type = &#39;raster&#39;) check_raster_coverage(rst = soil, vct_layer = &#39;hru&#39;, data_path = data_path, label = &#39;soil&#39;, cov_frc = 0.75) ## Project the soil layer to the grid and crs of the DEM save_soil_raster(soil, data_path) ## Prepare table with aggregated elevation, slope, soil for HRU units. aggregate_hru_dem_soil(data_path) ## Read and prepare the soil input tables and a soil/hru id table and write ## them into data_path/tables.sqlite build_soil_data(soil_lookup_path, soil_data_path, data_path) # Calculate land unit connectivity --------------------------------- ## Prepare raster layers based on the DEM and the surface channel objects ## that will be used in the calculation of the land object connectivity. prepare_terrain_land(data_path) ## Calculate the land object connectivity. The connection of each land ## object to neighboring land and water objects is calculated based on ## the flow accumulation and the D8 flow pointer along the object edge calculate_land_connectivity(data_path) ## Eliminate land object connections with small flow fractions. ## For each land object the flow fractions are compared to connection with ## the largest flow fraction of that land object. Connections are removed ## if their fraction is smaller than &#39;frc_thres&#39; relative to the largest one. ## The remaining land object connections are analyzed for infinite loop ## routing. For each land unit the connections are propagated and checked ## if the end up again in the same unit. reduce_land_connections(data_path, frc_thres) %&gt;% check_infinite_loops(., data_path, &#39;Land&#39;) ## If infinite loops were identified this routine tries to resolve the ## issues by selectively removing connections between land units in order ## to get rid of all infinite loops. resolve_loop_issues(data_path) # Calculate channel/reservoir connectivity ------------------------- ## Calculate the water object connectivity. The function returns the cha ## and res con_out tables in SWAT+ database format and writes them into ## data_path/tables.sqlite build_water_object_connectivity(data_path) ## Check the water objects for infinite loops. From the cha_res_con_out ## tables id_from/id_to links are generated and checked for infinite ## loop routing. prepare_water_links(data_path) %&gt;% check_infinite_loops(., data_path, &#39;Water&#39;, Inf) ## Calculate terrain properties such as elevation, slope, catchment area, ## channel width/depth for channel and reservoir objects and write them into ## data_path/tables.sqlite prepare_terrain_water(data_path) # Generate land object SWAT+ input tables -------------------------- ## Build the landuse.lum and a landuse/hru id table and write them into ## data_path/tables.sqlite build_landuse(data_path) ## Build the HRU SWAT+ input files and write them into data_path/tables.sqlite build_hru_input(data_path) ## Add wetlands to the HRUs and build the wetland input files and write them ## into data_path/tables.sqlite add_wetlands(data_path, wetland_landuse) # Generate water object SWAT+ input tables ------------------------- ## Build the SWAT+ cha input files and write them into data_path/tables.sqlite build_cha_input(data_path) ## Build the SWAT+ res input files and write them into data_path/tables.sqlite build_res_input(data_path) ## Build SWAT+ routing unit con_out based on &#39;land_connect_fraction&#39;. build_rout_con_out(data_path) ## Build the SWAT+ rout_unit input files and write them into ## data_path/tables.sqlite build_rout_input(data_path) ## Build the SWAT+ LSU input files and write them into data_path/tables.sqlite build_ls_unit_input(data_path) # Build aquifer input ---------------------------------------------- ## Build the SWAT+ aquifer input files for a single aquifer for the ## entire catchment. The connectivity to the channels with geomorphic ## flow must be added after writing the txt input files. ## This is not implemented in the script yet. build_single_aquifer_files(data_path) # Add point source inputs ------------------------------------------ ## Add point source inputs. The point source locations are provided ## with a point vector layer in the path &#39;point_path&#39;. Point source ## records can automatically be added from files in the same folder ## as the point source location layer. To be identified as point ## source data the files must be named as &lt;name&gt;_&lt;interval&gt;.csv, ## where &lt;name&gt; must be the name of a point int the vector layer ## and &lt;interval&gt; must be one of &#39;const&#39;, &#39;yr&#39;, &#39;mon&#39;, or &#39;day&#39; ## depending on the time intervals in the input data. add_point_sources(point_path, data_path, max_point_dist) # Create SWAT+ sqlite database ------------------------------------- ## Write the SWAT+Editor project database. The database will be located ## the &#39;project_path&#39;. After writing the database it can be opened and ## edited with the SWAT+Editor. create_swatplus_database(project_path, project_name) # ------------------------------------------------------------------------- # Switch to SWAT+Editor for further model parametrization # and continue with the step below after writing # the SWAT+ projects&#39; text input files # ------------------------------------------------------------------------- # Link aquifers and channels with geomorphic flow ------------------------- # A SWATbuildR model setup only has one single aquifer (in its current # version). This aquifer is linked with all channels through a channel- # aquifer-link file (aqu_cha.lin) in order to maintain recharge from the # aquifer into the channels using the geomorphic flow option of SWAT+ # The required input file cannot be written with the SWAT+Editor. # Therefore it has to be generated in a step after writing the # model text input files with the SWAT+Editor. link_aquifer_channels(txt_path) References "],["land-use-map.html", "Section 3 Land Use Map 3.1 AR5 Base map 3.2 Farm Fields 3.3 Dissolving superfluous polygons 3.4 Splitting Large Polygons 3.5 Channel network 3.6 Tile drainage 3.7 Clipping to Watershed 3.8 Adding unique IDs 3.9 BuildR Implementation", " Section 3 Land Use Map In this section we will construct the land use map.. The final result will resemble figure 2.5 from (Schürz Christoph et al. 2022): require(sf) require(dplyr) require(mapview) require(terra) 3.1 AR5 Base map As a basis for our land use we will use the AR5 map from NIBIO. A lower resolution version of this map can be downloaded from Kart8, and then high resolution map can be viewed in Kilden. The map has been pre-clipped to our research area to save on computational and data costs. ar5 &lt;- sf::read_sf(&quot;project_data/input/LU/basemap/ar5_clip.shp&quot;) plot(ar5[&quot;artype&quot;]) We are only interested in the artype column, so we will extract the geometry and the artype ar5_sel &lt;- ar5 %&gt;% select(geometry, artype) And we will re class the legend items into a legend SWATbuildR can understand. ar5_sel$type &lt;- NA ar5_sel$type[which(ar5_sel$artype==11)] = &quot;urml&quot; ar5_sel$type[which(ar5_sel$artype==12)] = &quot;utrn&quot; ar5_sel$type[which(ar5_sel$artype==21)] = &quot;agri&quot; ar5_sel$type[which(ar5_sel$artype==22)] = &quot;past&quot; ar5_sel$type[which(ar5_sel$artype==23)] = &quot;past&quot; ar5_sel$type[which(ar5_sel$artype==30)] = &quot;frst&quot; ar5_sel$type[which(ar5_sel$artype==50)] = &quot;rngb&quot; ar5_sel$type[which(ar5_sel$artype==60)] = &quot;wetf&quot; ar5_sel$type[which(ar5_sel$artype==81)] = &quot;watr&quot; plot(ar5_sel[&quot;type&quot;]) Time to save this file write_sf(ar5_sel, &quot;project_data/input/LU/basemap/AR5_sel.shp&quot;) To minimize computation time, we need to minimize the amount of polygons in this layer. length(ar5_sel$geometry) ## [1] 1161 Taking a closer look at the map: WS &lt;- mapview(read_sf(&quot;project_data/input/DEM/skuterud_basin_1m_drained.shp&quot;), alpha.region = 0, lwd = 3) LU &lt;- mapview(ar5_sel, zcol = &quot;type&quot;, alpha.region = 0.1) WS+LU There is much to remove and simplify, but before we do that, we should make sure we reach maximum “complexity” in our map. This is because if we simplify now, and then later burn in more polygons, our efforts will be wasted / inefficient. The first thing we need to add is the farm fields themselves. 3.2 Farm Fields As this setup is aiming to represent the field scale, we need to add the fields into our “landscape”. The catchment we have chosen is a “JOVA” catchment which monitors all sorts of things going on in the catchment, including what operations are conducted on all the fields. You can read about JOVA here. The delineation of th fields was provided to us by the JOVA team. Let’s take a look at the map: jova_skut_fields &lt;- read_sf(&quot;project_data/input/LU/agriculture/skifter_sku2.shp&quot;) jova_map &lt;- mapview(jova_skut_fields, alpha.region = .1, col.region = &quot;orange&quot;) jova_map It looks good, however, comparing it to the agricultural land from our basemap “AR5” reveals a problem: farm_map &lt;- ar5_sel %&gt;% filter(type == &quot;agri&quot;) %&gt;% mapview(alpha.region = .1) farm_map+jova_map Quite a bit of overlap. There (to my best knowledge) is no way of fixing this issue other than manual correction, which will be done in QGIS and documented here. The goal is a final map compatible with AR5 data. To start, we will extract just the agricultural fields, and save them to a file to be modified: farm_map &lt;- ar5_sel %&gt;% filter(type == &quot;agri&quot;) %&gt;% write_sf(&quot;project_data/input/LU/basemap/AR5_agri.shp&quot;) Here is the result of the manual QGIS work: Figure 3.1: JOVA fields burned into AR5, work performed manually with QGIS We can load this map in now lu_v2 &lt;- read_sf(&quot;project_data/input/LU/agriculture/skut_fields_ar5.shp&quot;) mapview(lu_v2, zcol = &quot;type&quot;) 3.3 Dissolving superfluous polygons 3.3.1 Removing Stream Polygons Our model setup, following the OPTAIN style setup, does not resolve water channels (streams) as polygons, instead they are encoded in “line” geometries. Our AR5 base map treats channels as polygons, therefore we need to remove them. This was done by replacing the watr type with either the neighboring rngb or frst. plot(lu_v2[&#39;type&#39;], xlim = c(603080.78,603192.64), ylim = c(6617292.19, 6617120.26)) lu_simple &lt;- read_sf(&quot;project_data/input/LU/simplification/lu_simple_2.shp&quot;) plot(lu_simple[&#39;type&#39;], xlim = c(603080.78,603192.64), ylim = c(6617292.19, 6617120.26)) 3.3.2 Merging urban and road In the urbanized part of our catchment (Ås), the road and urban polygons make up a complex network. As this model setup does not seek to resolve complex urban landscapes, we can safely reduce the complexity of “urban” urml and “road” utrn land uses in our map. par(mar = c(4, 4, .1, .1)) plot(lu_v2[&#39;type&#39;], xlim = c(601388.5,602807.8), ylim = c(6616711.7, 6615482.1)) plot(lu_simple[&#39;type&#39;], xlim = c(601388.5,602807.8), ylim = c(6616711.7, 6615482.1)) Additionally, all polygons with a perimeter less than &lt;50m (excluding water) or area less than 50m2 were dissolved into their neighboring polygons. Mostly, these were artifacts of infinitely small shapes. 3.4 Splitting Large Polygons We need to split large polygons into smaller ones, akin to the size of our fields. This is further explained in the OPTAIN modelling protocol, and can be seen in figure 2.6 (Schürz et al. 2022) 3.4.1 Splitting forests Forests sometimes can represent huge parts of the landscape, allowing them to rout water between polygons that are spatially very far apart. To prevent this effect, we need to split up our large forests. This was done by intersecting the large forests with the “Løsmasser” map from kart8 (add ref!). This map will later be used to create the soil map. This allows the splits of the forests to match the expected hydrological response. These intersections were subsequently manually adjusted such that any polygons which were too small were re-merged with neighboring. Any polygons that were large, yet not intersected by “Loesmasser” were manually cut in line with topologically relevant landscape changes. Any polygons “too big” even after intersection were also split. The reference point for “too big” was the average agricultural field size. par(mar = c(4, 4, .1, .1)) plot(lu_simple[&#39;type&#39;], xlim = c(602845.1,604437.2), ylim = c(6616034.3, 6615302.6)) forest_simple &lt;- read_sf(&quot;project_data/input/LU/forest/forest_final.shp&quot;) plot(forest_simple[&#39;type&#39;], xlim = c(602845.1,604437.2), ylim = c(6616034.3, 6615302.6)) 3.4.2 Splitting Roads Roads were split such that their perimeter did not exceed 400m. Cuts were made in locations topologically relevant to other landscape elements (i.e. at locations where the landscape changes beside the road). par(mar = c(4, 4, .1, .1)) plot(lu_v2[&#39;type&#39;], xlim = c(602074.06,602625.35), ylim = c(6616575.39, 6616364.10)) plot(lu_simple[&#39;type&#39;], xlim = c(602074.06,602625.35), ylim = c(6616575.39, 6616364.10)) The current geometry of our land use map is now finished. some work needs to be done on the attributes and channels. For now we can save our land use map for further work on the attributes in R. Many small polygons were created in the processing, these were merged with their neighboring polygons using “Eliminate selected polygons” in QGIS. # cleanup lu_map &lt;- forest_simple %&gt;% select(geometry, artype, type, arskogbon, artreslag, GNR, BNR, NAVN, GARDSREF, GNRBNR, SKIFTENR, gard_skif, jordart, jorda_navn, infilt, infil_navn, grunnvann, grunn_navn) write_sf(lu_map, &quot;project_data/input/LU/lu_skuterud.shp&quot;) 3.5 Channel network The channel network must be a GIS line vector layer. it needs fields “id” and “type” where type defines whether it is a surface (cha) or subsurface (sub) channel. Subsurface channels do not receive water from neighboring polygons. In our setup there will be predominantly used for tile drain inlets. The channel network connects to polygons of type watr. The direction of the vectors cannot be ignored, it defines the flow of the water. Splitting a channel (distinct feature with differing ID) is only necessary at confluence points or at points where measured timeseries are available. Cross pond splitting is not needed. The channel network was created manually using various maps for assistance. In addition to the surface channel network, subsurface channels from tile drain inlets have been added. The locations of these were provided by Robert Barneveld. Here is the provisional result: tiledrain_inlets &lt;- read_sf(&quot;project_data/input/LU/tiledrains/inlets.shp&quot;) channel_network &lt;- read_sf(&quot;project_data/input/LU/channels/skuterud_streams.shp&quot;) mapview(channel_network, zcol = &quot;type&quot;)+mapview(tiledrain_inlets)+WS TODO: check for road dams TODO: have an expert check it TODO: decide on forest channels 3.6 Tile drainage To incorporate tile-drained on a field-scale in our model setup, we need to provide buildR with an extra column in our land use map: drainage. This column will contain the ID of the channel to which the field is tile-drained into. As no complete records exist as to what field is drained, and where it drains to, we need to use a proxy. This proxy will be the “drainage class” from the NIBIO “jordmonn” map. You can read more about it here. The classes and their interpretation are as follows: Drainage Class Meaning Interpretation 1 Self-drained No tile drainage 2 Self-draining with wet drafts (?) No tile drainage 3 Partially self-drained Tile drainage 4 Not self-drained Tile drainage dren_klass &lt;- read_sf(&quot;project_data/input/LU/tiledrains/drainage_class_skuterud.shp&quot;) plot(dren_klass[&#39;klassenavn&#39;]) dren_klass &lt;- dren_klass %&gt;% select(geometry, klasse) Note, class 2 is not in our catchment area. To determine which agricultural fields need to be tile drained, we will do a spatial join and add drainage to fields with classes 3 and 4. lu_skut &lt;- read_sf(&quot;project_data/input/LU/lu_skuterud.shp&quot;) dren_klass &lt;- dren_klass %&gt;% st_transform(st_crs(lu_skut)) dren_join &lt;- st_join(lu_skut, dren_klass, largest = TRUE) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries dren_join&lt;-dren_join %&gt;% filter(type == &quot;agri&quot;) dren_join$klasse &lt;- dren_join$klasse %&gt;% as.character() mapview(dren_join, zcol = &quot;klasse&quot;) write_sf(dren_join,&quot;project_data/input/LU/tiledrains/drain_id.shp&quot;) As we can see, all but 6 fields are drained. We will determine which the sub-basins of each defined channel and check which fields fall into that basin. These fields will be assigned to that channel. channel_network &lt;- read_sf(&quot;project_data/input/LU/channels/skuterud_streams.shp&quot;) # don&#39;t ask me how or why this works. Point is, it does. # sample = 0 creates points at the start of each line. # sample = 1 creates points at the end of each line. nodes &lt;- st_line_sample(channel_network, sample = 0) %&gt;% st_as_sf() nodes &lt;- st_transform(nodes, crs(channel_network)) # attaching channel IDs to the points nodes &lt;- st_join(nodes, channel_network, join = st_touches) %&gt;% st_difference() nodes &lt;- st_cast(nodes, &quot;POINT&quot;) ## Warning in st_cast.sf(nodes, &quot;POINT&quot;): repeating attributes for all ## sub-geometries for which they may not be constant mapview(channel_network)+mapview(nodes) dem &lt;- rast(&quot;project_data/input/DEM/skuterud_DEM.tif&quot;) nodes &lt;- st_transform(nodes, crs(dem)) write_sf(nodes,&quot;project_data/input/lu/tiledrains/channel_nodes.shp&quot;) To figure out which field drains into which, we will create sub-basins for each of these points, and assign the fields to the appropriate sub-basin. First they need to be snapped require(whitebox) wbt_jenson_snap_pour_points( pour_pts = &quot;project_data/input/lu/tiledrains/channel_nodes.shp&quot;, streams = &quot;project_data/input/DEM/wbt_intermediates/raster_streams_drained.tif&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/channel_nodes_snapped.shp&quot;, snap_dist = 30 ) then we can create the sub-basins wbt_watershed( d8_pntr = &quot;project_data/input/DEM/wbt_intermediates/d8_pointer_drained.tif&quot;, pour_pts = &quot;project_data/input/DEM/wbt_intermediates/channel_nodes_snapped.shp&quot;, output = &quot;project_data/input/DEM/wbt_intermediates/channel_node_subbasin.tif&quot; ) subbasins &lt;- rast(&quot;project_data/input/DEM/wbt_intermediates/channel_node_subbasin.tif&quot;) plot(subbasins) Beautiful. An interactive check: subbasins_poly &lt;- as.polygons(subbasins) %&gt;% st_as_sf() # bandaid fix subbasins_poly$channel_node_subbasin &lt;- subbasins_poly$channel_node_subbasin-1 mapview(subbasins_poly)+mapview(nodes) subbasins_poly &lt;- st_transform(subbasins_poly, crs(lu_skut)) write_sf(subbasins_poly, &quot;project_data/input/LU/tiledrains/channel_subbasins.shp&quot;) ## Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI ## Shapefile driver Now, we add the ID of the sub-basin to the field that is within it, only if the drainage class is 3 or 4. lu_skut &lt;- read_sf(&quot;project_data/input/LU/lu_skuterud.shp&quot;) join1 &lt;- st_join(lu_skut, subbasins_poly, largest = T) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries join_full &lt;- st_join(join1, dren_klass, largest = T) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries lu_skut_drain_id &lt;- join_full %&gt;% mutate(drainage = case_when( klasse &gt; 2 &amp; type == &quot;agri&quot; &amp; (is.na(SKIFTENR) == FALSE) ~ channel_node_subbasin)) mapview(lu_skut_drain_id, zcol = &quot;drainage&quot;) Very nice. Now all we need is to add a unique ID to our polygons for buildR. For agricultural fields this will be the farm+field number, for all others just the type. require(stringr) # replacing / with _ lu_skut_drain_id$gard_skif&lt;- lu_skut_drain_id$gard_skif %&gt;% str_replace(&quot;/&quot;, &quot;_&quot;) %&gt;% paste0(&quot;a_&quot;, .) lu_skut_typed &lt;- lu_skut_drain_id %&gt;% mutate(type = case_when(type != &quot;agri&quot; ~ type, type == &quot;agri&quot; ~ gard_skif)) 3.7 Clipping to Watershed We only need the polygons within our watershed, so we crop to that. Note: We are using the basin as calculated by BuildR ws &lt;- read_sf(&quot;project_data/skuterud_swat/skuterud/data/vector/basin.shp&quot;) lu_skut_typed&lt;-st_transform(lu_skut_typed, crs(ws)) lu_skut_typed&lt;-st_make_valid(lu_skut_typed) lu_crop &lt;- st_intersection(lu_skut_typed, ws) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries write_sf(lu_crop, &quot;project_data/input/lu/lu_skuterud_final.shp&quot;) ## Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI ## Shapefile driver mapview(lu_crop) We now have many tiny polygons at the border which were cut. We can merge them with their largest neighbor. I don’t know how to do this in R yet, so this part will be done manually in QGIS. # lu_crop2 &lt;- st_cast(lu_crop, &quot;POLYGON&quot;) # lu_crop$AREA &lt;- st_area(lu_crop) %&gt;% as.numeric() # remove &lt;- lu_crop$AREA &lt; 150 # lu_crop &lt;- vect(lu_crop) # x &lt;- combineGeoms(lu_crop[!remove,],lu_crop[remove,], boundary = TRUE, dissolve=TRUE) # mapview(x) # write_sf(x %&gt;% st_as_sf(), &quot;project_data/input/lu/lu_skuterud_final.shp&quot;) Here is the end product: lu_finished &lt;- read_sf(&quot;project_data/input/LU/lu_skuterud_final_manual.shp&quot;) mapview(lu_finished) 3.8 Adding unique IDs We also need a unique numeric id for each polygon: lu &lt;- lu_finished %&gt;% mutate(id = row_number()) %&gt;% select(id, type, drainag) lu&lt;-rename(lu, drainage = drainag) mapview(lu, zcol = &quot;type&quot;) write_sf(lu, &quot;project_data/input/LU/lu_buildRready.shp&quot;) 3.9 BuildR Implementation # load functions: fns &lt;- sapply(list.files(&#39;project_data/SWATbuildR/functions/&#39;, full.names = T), source) rm(fns) ## Install and load R packages install_load(crayon_1.5.1, dplyr_1.0.10, forcats_0.5.1, ggplot2_3.3.6, lubridate_1.8.0, purrr_1.0.0, readr_2.1.2, readxl_1.4.0, stringr_1.4.0, tibble_3.1.8, tidyr_1.2.0, vroom_1.5.7) install_load(sf_1.0-8, sfheaders_0.4.0, lwgeom_0.2-8, terra_1.7-3, whitebox_2.1.5, units_0.8-0) install_load(DBI_1.1.3, RSQLite_2.2.15) land_path = &quot;project_data/input/LU/lu_buildRready.shp&quot; project_path &lt;- &#39;project_data/skuterud_swat/&#39; project_name &lt;- &#39;skuterud&#39; data_path &lt;- paste(project_path, project_name, &#39;data&#39;, sep = &#39;/&#39;) channel_path &lt;- &quot;project_data/input/lu/channels/skuterud_streams.shp&quot; project_layer = TRUE ## Land layer land &lt;- read_sf(land_path) %&gt;% check_layer_attributes(., type_to_lower = FALSE) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;land&#39;, type = &#39;vector&#39;) ## Check function saves layer into data/vector after all checks were successful check_polygon_topology(layer = land, data_path = data_path, label = &#39;land&#39;, area_fct = 0.05, cvrg_frc = 99.9, checks = c(T,F,T,T,T,T,T,T)) ## Running topological checks and modifications for the land layer: ## ## Intersection of land layer with basin boundary layer... ## ✔ Intersection completed. ## Analyzing land layer for MULTIPOLYGON features... ## ✔ No MULTIPOLYGON features identified. ## Analyzing land layer for invalid features... ## ✔ No invalid features identified. ## Analyzing land layer for very small feature areas... ## ✔ No small features identified. ## Analyzing land layer for features covered by other features... ## ✔ No covered features identified. ## Analyzing land layer for overlapping features... ## ✔ No overlapping features identified. ## Analyzing land layer coverage with basin boundary... ## ✔ Layer coverage OK. ## ## ## ✔ All checks successful! Saving intersected land layer. ## Split the land layer in to HRU (land) and reservoir (water) objects split_land_layer(data_path) ## Channel layer if(!is.null(channel_path)) { channel &lt;- read_sf(channel_path) %&gt;% check_layer_attributes(., type_to_lower = TRUE) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;channel&#39;, type = &#39;vector&#39;) ## Check function saves layer into data/vector after all checks were successful ### altered length fraction to 0... check_line_topology(layer = channel, data_path = data_path, label = &#39;channel&#39;, length_fct = 0.00, can_cross = TRUE) } ## Running topological checks and modifications for the channel layer: ## ## Intersection of channel layer with basin boundary layer... ## ✔ Intersection completed. ## Analyzing channel layer for MULTILINE features... ## ✔ No MULTILINE features identified. ## Analyzing channel layer for invalid features... ## ✔ No invalid features identified. ## Analyzing channel layer for very short feature lengths... ## ✔ No small features identified. ## ## ✔ All checks successful! Saving intersected channel layer. ### id of the outlet channel id_cha_out = 27 id_res_out &lt;- NULL check_cha_res_connectivity(data_path, id_cha_out, id_res_out) ## Preparing channel and reservoir features... ## ✔ OK! ## Analyzing connectivity of water object network... ## ✔ No disconnected channels identified. ## ✔ No disconnected reservoirs identified. ## ## ## ✔ Water object connectivity check successful! ## Check if any defined channel ids for drainage from land objects do not exist check_land_drain_ids(data_path) ## Load and check DEM raster dem_path = &quot;project_data/input/DEM/skuterud_DEM.tif&quot; dem &lt;- rast(dem_path) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;dem&#39;, type = &#39;raster&#39;) check_raster_coverage(rst = dem, vct_layer = &#39;land&#39;, data_path = data_path, label = &#39;dem&#39;, cov_frc = 0.95) #Save dem layer in data/raster save_dem_slope_raster(dem, data_path) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
